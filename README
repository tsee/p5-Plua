=pod

=head1 PLua

Interfacing between Perl and Lua as seamlessly and efficiently as
unreasonably possible!

=head1 Introduction

Lua (and specifically luajit) is really rather efficient. And it's a
safe language. A "scripting" language. And it's not too painful to
deal with from C. The motiviation is to allow Perl to use
tightly-coupled blocks of embedded Lua code to speed up hot code paths.

In other words, you can do this:

  use PLua;
  bla bla bla Perl code bla bla
  my $foo = 1;
  lua {
    local bar = $foo.int * 42
    $foo = some_lua_function(bar)
  }
  bla more Perl using modified $foo here

The details are (likely unsurprisingly) a bit involved.

Since this is an experiment and proof-of-principle quality code base
this README is initially (hopefully) going to be mostly a guide to
getting started with hacking on PLua itself.

=head1 Building

Make sure to have a copy of Lua (likely luajit) compiled and available
from a standard include/linking location. Possibly edit Makefile.PL to
point at the directory of the location if you use a custom one. Then,
it's just the usual:

  perl Makefile.PL
  make
  make test (some tests fail!)

You can enable debug mode with a number of assertions like this:

  DEBUG=1 perl Makefile.PL
  make
  make test

Since I dislike fuzzing with build systems and I am lazy (and the DEBUG=1
is a horrible hack), I usually work like this:

  hack hack hack
  make clean; DEBUG=1 perl Makefile.PL && make test
  rinse, repeat

Which is still fast enough with this code base. Patches welcome (really).

=head1 Understanding the Implementation

You'll need at least some basic knowledge of the Perl API in order to make
sense of this, I suppose.

PLua uses Perl's keyword plugin mechanism to generate a custom OP (OPs
being the basic building block of Perl's ugly step-sister of an excuse
for an AST).
  
=head2 What happens when you load "Plua"?

=over 2

=item *

We use an XS C<BOOT> (see L<perlxs>) section to call the bootstrapping function
C<plu_init_global_state> (see F<plu_global_state.h> and F<plu_global_state.c>).
This in turn will perform the following steps:

=item *

Create a global (I know...) C<lua_State> object / Lua runtime for use by 
PLua. This lives in C<PLU_lua_int> right now. Will eventually move
elsewhere. (threads, reuse, coroutines, etc.)

=item *

Create and register the description of our custom Lua OP (C<PLU_xop>).
Also register a hook for freeing OPs of our custom type since they
have additional data attached to each instance.

=iteam *

Register our keyword plugin (see function C<plu_my_keyword_plugin>
in F<plu_parse_kw.h>).

=item *

Register global destruction cleanup hook (Perl_call_atexit calling
C<plu_global_state_final_cleanup>) for the Lua interpreter and
other global state.

=back

=head2 What happens at compile time when you do "lua {...}"?

=over 2

=item *

Perl's tokenizer finds the unknown "lua" keyword. It invokes the keyword
plugin mechanism which eventually finds our particular keyword plugin
(see above) and calls it. We detect that it's "our" keyword and...

=item *

I<HACK ALERT!> This must change in they future.

... use the Perl lexer API to determine the Lua delimiter (one or many C<{>)
and then use said API to find the corresponding number of successive (without
whitespace) closing braces to end the Lua block.
This should be replaced by a proper (extended) Lua parser later.

=item *

I<MORE HACKS!>

The scanner code is modified by C<plu_munge_lua_code> in F<plu_lua_syntax_ext.c>.
This is currently deals with syntax like "$x.int" or "$x = ...". It works
by scanning the code with regexes (in Perl, see F<lib/PLua.pm>), then
doing all lexical PAD offset lookups for the scalars (back in C using variations on
C<pad_findmy> / C<pad_findmy_pvn>), then doing search/replace of the above
snippets with things like "perl.val_to_$type($padoffset)".

In order to close over Perl lexicals properly, this will most certainly
have to be amended.

=item *

The modified code is passed to the Lua compiler, which puts a Lua function
on the Lua stack (if all goes well), see C<plu_compile_lua_block_or_croak>
in F<plu_lua.c>.

=item *

Since it's not legal Lua API to pop functions off the stack for outside-Lua-use and
then putting them back on, we keep them within Lua and use the ref mechanism to
store it within the lua_State (see Lua's manual on C<luaL_ref>). Then we construct
a custom OP to hold all the necessary data for runtime, see C<plu_prepare_custom_op>
in F<plu_op.c>

=back

TODO write about run-time behaviour
